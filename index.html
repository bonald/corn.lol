<!DOCTYPE html><html><head><meta charset="UTF-8" /><title>corn.lol</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
</head><body><div id="root"></div><div id="footer"></div><script type="text/babel">

    // default minimum trade amounts
    var bitmexMin = 95000;
    var bitfinexMin = 1000;
    var coinbaseMin = 100;


    var showPrices = true;

    // exchanges on
    var bitmexEnabled = true;
    var bitfinexEnabled = true;
    var coinbaseEnabled = true;


    // for font/colors
    var bitmexSize1 = 1;
    var bitmexSize2 = 1000;
    var bitmexSize3 = 10000;
    var bitmexSize4 = 100000;
    var bitmexSize5 = 500000;
    var bitmexSize6 = 1000000;
    var bitfinexSize1 = 1;
    var bitfinexSize2 = 100;
    var bitfinexSize3 = 1000;
    var bitfinexSize4 = 50000;
    var bitfinexSize5 = 100000;
    var bitfinexSize6 = 200000;

    // trades container
    var trades = null;

    class Start extends React.Component {

        constructor(props) {
            super(props);
            this.state = {data: []};
            this.instance = this;

            this.bitmexWebSocketClient();
            // this.bitfinexWebSocketClient();
            this.setupCoinbaseWebsocketClient();
            this.setupSettings();
            this.scrollUpLoop();
        }


        bitmexWebSocketClient() {
            let c = this.instance;
            if (c.bitmexSocket != null) {c.bitmexSocket.close();c.bitmexSocket = null;}

            c.bitmexSocket = new WebSocket("wss://www.bitmex.com/realtime?subscribe=trade:XBTUSD");
            c.bitmexSocket.onmessage = function(tradeMessage) {
                let tradeRaw = JSON.parse(tradeMessage.data);
                if (tradeRaw.data == null) {return;}
                let trade = Start.bitmexTrade(tradeRaw.data);
                if (trades == null) {
                    trades = trade;
                } else {
                    trades = trade.concat(trades);
                    if (trades.length >= 1000) {trades.splice(trades.length - 5)}
                }
                c.setStreamData({data: trades});
            };
        }

        static bitmexTrade(tradeRaw) {
            let trade = [];
            let totalSize = 0;
            for (let i = 0; i < tradeRaw.length; i++) {totalSize += tradeRaw[i].size;}

            let firstPrice = tradeRaw[0].price;
            let lastPrice = tradeRaw[tradeRaw.length-1].price;

            trade.push({
                symbol: "XBTUSD",
                price:lastPrice,
                timestamp: tradeRaw[0].timestamp,
                side: tradeRaw[0].side,
                exchangeName: "bitmex",
                startTime: Date.now(),
                firstPrice: firstPrice,
                lastPrice: lastPrice,
                size: totalSize
            });
            return trade;
        }

        bitfinexWebSocketClient() {
            var c = this.instance;
            if (c.bitfinexSocket != null) {c.bitfinexSocket.close();c.bitfinexSocket = null;}
            c.bitfinexSocket = new WebSocket("wss://api.bitfinex.com/ws")
            c.bitfinexSocket.onopen = function() {
                c.bitfinexSocket.send("{\n" +
                    "  \"event\": \"subscribe\",\n" +
                    "  \"channel\": \"trades\",\n" +
                    "  \"pair\": \"BTCUSD\"\n" +
                    "}")
            };
            c.bitfinexSocket.onmessage = function(event) {
                let trade = JSON.parse(event.data);
                if (trade == null || trade[1] !== "te") {return}

                let trade2 = Start.bitfinexTrade(trade)

                if (trades != null && trades[0].timestamp === trade2[0].timestamp && trades[0].side === trade2[0].side) {
                    trades[0].btcAmt += trade2[0].btcAmt
                    trades[0].size += trade2[0].size
                    trades[0].lastPrice = trade2[0].price
                } else {
                    if (trades == null) {
                        trades = trade2;
                    } else {
                        if (trades.length >= 1000) {trade2.splice(trades.length - 5);}
                        trades = trade2.concat(trades);
                    }
                }
                c.setStreamData({data: trades});
            };
        }

        static bitfinexTrade(tradeRaw) {
            let trade = [];
            trade.push({
                symbol: "BTCUSD",
                price:tradeRaw[4],
                size: parseInt(tradeRaw[5]*tradeRaw[4]),
                timestamp: tradeRaw[3],
                side: tradeRaw[5]>0,
                exchangeName: "bitfinex",
                startTime: Date.now(),
                btcAmt: tradeRaw[5],
                firstPrice: tradeRaw[4],
                lastPrice: tradeRaw[4]
            });
            return trade;
        }


        setupCoinbaseWebsocketClient() {
            var c = this.instance;
            if (c.coinbaseSocket != null) {c.coinbaseSocket.close();c.coinbaseSocket = null;}
            c.coinbaseSocket = new WebSocket("wss://ws-feed.pro.coinbase.com")
            c.coinbaseSocket.onopen = function() {
                c.coinbaseSocket.send("{\"type\": \"subscribe\", \"product_ids\": [\"BTC-USD\"],\"channels\": [\"matches\"]}")
            };
            c.coinbaseSocket.onmessage = function(event) {
                let tradeRaw = JSON.parse(event.data);

                if (tradeRaw == null || tradeRaw.type !== "match") {return}

                console.log("cb trade size: " + tradeRaw.size + " timestamp: " + tradeRaw.time)

                let trade = Start.coinbaseTrade(tradeRaw)

                console.log("time after func: " + trade.timestamp)

                console.log("size " + trade.size)
                console.log("current timestamp: " + trades[0].timestamp + " current side: " + trades[0].side + " thistrade timestmap: " + trade.timestamp + " new side: " + trade.side + " ts equal: " + (trades[0].timestamp===trade.timestamp))
                if (trades != null && trades[0].timestamp === trade.timestamp && trades[0].side === (trade.side==="sell")) {
                    console.log("ADDING " + trade.size)
                    trades[0].btcAmt += trade.btcAmt
                    trades[0].size = parseFloat(trades[0].size) + parseFloat(trade.size);
                        trades[0].lastPrice = trade.price
                    console.log("new size: " + trades[0].size)
                } else {
                    if (trades == null) {
                        trades = trade;
                    } else {
                        if (trades.length >= 1000) {trade.splice(trades.length - 5);}
                        console.log("newtrade size " + trade.size + "time: " + trade.timestamp)
                        trades = trade.concat(trades);
                    }
                }
                c.setStreamData({data: trades});
            };
        }

        static coinbaseTrade(tradeRaw) {


            let size= parseFloat(tradeRaw.size)*parseFloat(tradeRaw.price)

            let time = Date.parse(tradeRaw.time)

            console.log("time parsed: " + time)

            let trade = [];
            trade.push({
                symbol: "BTCUSD",
                price:parseFloat(tradeRaw.price).toFixed(1),
                size: size,
                side: tradeRaw.side==="sell",
                timestamp: time,
                exchangeName: "coinbase",
                startTime: Date.now(),
                btcAmt: tradeRaw.size,
                firstPrice: parseFloat(tradeRaw.price).toFixed(1),
                lastPrice: parseFloat(tradeRaw.price).toFixed(1)
            });

            trade.btcAmt = parseFloat(tradeRaw.size).toFixed(1);
            trade.timestamp = time;
            trade.size = parseFloat(size).toFixed(0);
            trade.side = tradeRaw.side==="sell";
            return trade;
        }

        setStreamData(data){
            this.setState(data);
        }

        render() {
            return (
                <div id="tableandbottom">
                    <div id="maintablediv">
                        <Table data={this.state.data}/>
                    </div>
                    <div id="hiddendiv">
                        <a id="settingslink" href="#"><img src="https://i.imgur.com/6AoPcNm.png" height="30" width="30"></img></a>
                        <a id="clearlink" href="#"><img src="https://i.imgur.com/NkTQRNj.png" height="30" width="30"></img></a>
                        <a id="minimizelink" href="#"><img src="https://i.imgur.com/NoBQwYO.png" height="30" width="30"></img></a>
                    </div>
                </div>
            );
        }

        setupSettings() {
            window.onload = function() {

                document.getElementById("bitmexMinField").onchange = function() {
                    bitmexMin = document.getElementById("bitmexMinField").value;
                };

                document.getElementById("bitfinexMinField").onchange = function() {
                    bitfinexMin = document.getElementById("bitfinexMinField").value;
                };

                document.getElementById("coinbaseMinField").onchange = function() {
                    coinbaseMin = document.getElementById("coinbaseMinField").value;
                };

                let settingslink = document.getElementById("settingslink");
                settingslink.onclick = function() {
                    let modal = document.getElementById('myModal');
                    let span = document.getElementsByClassName("close")[0];
                    modal.style.display = "block";
                    span.onclick = function() {
                        modal.style.display = "none";
                    }
                    window.onclick = function(event) {
                        if (event.target === modal) {
                            modal.style.display = "none";
                        }
                    }
                };

                var clearlink = document.getElementById("clearlink");
                clearlink.onclick = function() {
                    trades = null;
                }

                var minimizelink = document.getElementById("minimizelink");
                minimizelink.onclick = function() {
                    console.log("minimize table")
                }

                document.getElementById('bitmexMinField').value = bitmexMin;
                document.getElementById('bitfinexMinField').value = bitfinexMin;
                document.getElementById('coinbaseMinField').value = coinbaseMin;


                document.getElementById('bitmexEnabledButton').checked = bitmexEnabled;
                document.getElementById('bitfinexEnabledButton').checked = bitfinexEnabled;
                document.getElementById('coinbaseEnabledButton').checked = coinbaseEnabled;

            };
        }

        scrollUpLoop() {
            setInterval(function(){
                document.getElementById("maintablediv").scrollTo({
                    'behavior': 'smooth',
                    'left': 0,
                    'top': 0
                })
            }, 10000);
        }


    }

    function getKformat(size, iteration) {
        if (size < 1000) {return Row.lowFormat(size);}
        let c = ["k", "m"];
        let d = (size / 100) / 10.0;
        let isRound = (d * 10) % 10 === 0;
        return (d < 1000 ?
            ((d > 99.9 || isRound || (!isRound && d > 9.99) ?
                    d.toFixed(0) * 10 / 10 : d.toFixed(1) + ""
            ) + "" + c[iteration]) : getKformat(d, iteration + 1) ) ;
    }

    class Row extends React.Component {
        render() {
            const {data} = this.props;
            const row = data.map((data, i) =>
                <tr className={"traderow " + (data.exchangeName==="coinbase"?"bitfinex":data.exchangeName) + " " + Row.getSizeGroup(data) + " " + (Math.abs(data.size)< Row.getMinForExchange(data)?"hide":"")} key={i} bgcolor={Row.getBgColor(data)}>
                    <td id="tradeIcon">{Row.getIcon(data)}</td>
                    <td id="tradeSize">{getKformat(Math.abs(parseFloat(data.size)), 0)}</td>
                    <td width="100%" id="spacer">{" "}</td>
                    <td id="slip">{Row.getSlip(data)}</td>
                    <td id="btcAmt">{Row.getBtcShow(data)}</td>
                    <td id="tradePrice">{showPrices?("@ " + parseFloat(data.lastPrice).toFixed(1)):null}</td>
                    <td id="elapsedTime">{ Row.getTimeElapsed(data)}</td>
                </tr>
            );
            return (<tbody>{row}</tbody>);
        }



        static lowFormat(size) {
            return Math.abs(Math.round(size)).toFixed(0);
        }

        static getTimeElapsed(data) {
            var timeElapsed = parseInt((Date.now()-data.startTime)/1000);
            if (timeElapsed===0) {
                return "now";
            } else if (timeElapsed < 60) {
                return timeElapsed + "s";
            } else {
                return parseInt(timeElapsed/60) + "m"
            }
        }

        static getBtcShow(data) {
            if (data.exchangeName==="bitfinex" || data.exchangeName==="coinbase") {
                var abs = Math.abs(data.btcAmt)
                return " " + abs>9?(abs.toFixed(0) + "btc"):(abs.toFixed(1) + " btc")
            } else {
                return null;
            }
        }

        static getSlip(data) {
            var slip = data.lastPrice-data.firstPrice
            if (Math.abs(slip)>=0.5) {
                return (slip<0?"[↘ ":"[↗ ") + Math.abs(slip).toFixed(1) + "]"
            } else {
                return null
            }
        }

        static getMinForExchange(data) {
            if (data.exchangeName==="bitmex") {
                return bitmexMin;
            } else if (data.exchangeName==="bitfinex") {
                return bitfinexMin;
            } else if (data.exchangeName==="coinbase") {
                return coinbaseMin;
            }
        }

        static getSizeGroup(data) {
            if (data.exchangeName==="bitmex") {
                if (data.size >= bitmexSize6) {return "size6"
                } else if (data.size >= bitmexSize5) {return "size5"
                } else if (data.size >= bitmexSize4) {return "size4"
                } else if (data.size >= bitmexSize3) {return "size3"
                } else if (data.size >= bitmexSize2) {return "size2"
                } else {return "size1"}
            } else if (data.exchangeName==="bitfinex" || data.exchangeName==="coinbase") {
                if (Math.abs(data.size) >= bitfinexSize6) {return "size6"
                } else if (Math.abs(data.size) >= bitfinexSize5) {return "size5"
                } else if (Math.abs(data.size) >= bitfinexSize4) {return "size4"
                } else if (Math.abs(data.size) >= bitfinexSize3) {return "size3"
                } else if (Math.abs(data.size) >= bitfinexSize2) {return "size2"
                } else {return "size1"}
            }
        }

        static getIcon(data) {
            if (data.exchangeName==="bitmex") {return <img src="https://i.imgur.com/87OPgLV.png" alt="bitmex"/>}
            else if (data.exchangeName==="bitfinex") {return <img src="https://i.imgur.com/tEMPQFj.png" alt="finex"/>}
            else if (data.exchangeName==="coinbase") {return <img src="https://i.imgur.com/Tc9hxOl.png" alt="gdax"/>}
        }

        static getBgColor(data) {
            var side = data.side;
            var size = Math.abs(data.size);

            var intensity = Math.abs(size) / 4200;

            if (intensity > 165) {
                intensity = 165;
            } else if (intensity < 1) {
                intensity = 1;
            }

            if (side) {
                return rgb2hex(170 - intensity, 255 - intensity / 2, 170 - intensity)
            } else {
                return rgb2hex(255 - intensity / 2, 170 - intensity, 170 - intensity)
            }

            function rgb2hex(red, green, blue) {
                var rgb = blue | (green << 8) | (red << 16);
                return '#' + (0x1000000 + rgb).toString(16).slice(1)
            }
        }
    }

    class Table extends React.Component {
        constructor(props) {super(props)}
        render() { return (<table className="table1"><Row data={this.props.data} /></table>)}
    }

    class Footer extends React.Component {

        constructor(props) {super(props);}

        render() {
            return (
                <div>
                    <div id="footerdiv">
                        <div id="footerleft">
                            <b>&hearts; corn.lol </b>
                            <small>[&copy; 2019 boppleton industries] - under construction</small>
                        </div>
                        <div id="footerright">
                            <a href="https://github.com/boppleton/corn.lol">github</a>
                        </div>
                    </div>

                    <div id="myModal" className="modal">

                        <div className="modal-content">
                            <div className="modal-header">
                                <span className="close">&times;</span>
                                <h2>ticker #1 settings</h2>
                            </div>

                            <div className="modal-body">
                                <div className="settingsitem">
                                    <input id="bitmexEnabledButton" type="checkbox" name="bitmexEnabledButton"/>
                                    <b>  bitmex  </b>
                                    <input id="bitmexMinField" type="number" name="bitmexMinField" min="1" max="10000000"/>
                                </div>

                                <div className="settingsitem">
                                    <input id="bitfinexEnabledButton" type="checkbox" name="bitfinexEnabledButton"/>
                                    <b>  bitfinex  </b>
                                    <input id="bitfinexMinField" type="number" name="bitfinexMinField" min="1" max="10000000"/>
                                </div>

                                <div className="settingsitem">
                                    <input id="coinbaseEnabledButton" type="checkbox" name="coinbaseEnabledButton"/>
                                    <b>  coinbase  </b>
                                    <input id="coinbaseMinField" type="number" name="coinbaseMinField" min="1" max="10000000"/>
                                </div>
                            </div>

                            <div className="modal-footer">
                                <hr/><hr/><hr/>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }
    }

    ReactDOM.render(<Start />, document.getElementById('root'));

    ReactDOM.render(<Footer />, document.getElementById('footer'));


</script>

<style>

    * {
        margin: 0;
        padding: 0;
    }

    body, html {
        width: 100%;
        height: 100%;


        overflow: hidden;

        background:
                radial-gradient(black 15%, transparent 16%) 0 0,
                radial-gradient(black 15%, transparent 16%) 8px 8px,
                radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 0 1px,
                radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 8px 9px;
        background-color:#282828;
        background-size:16px 16px;
    }

    #icon img {
        /*width: 100%;*/
    }


    a {
        color: #858585;
    }

    #footer {
        font-family: 'Raleway', sans-serif;

        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        background-color: #4f4f4f;
        color: #858585;
        text-align: left;


    }

    #footerdiv {
        padding: 5px;
    }

    #footerdiv b {
        font-size: 18px;
        color: #9c9c9c;
        /*-webkit-text-stroke: 1px black;*/
    }

    #footerleft {
        float: left;
        text-align: left;

    }

    #footerleft {
        text-align: center;
    }

    #footerright {
        text-align: right;
    }

    #maintablediv {

        border: 2px solid #525252;

        margin: 5px;
        /*padding: 2px;*/
        width: 250px;
        height: 780px;

    }



    #maintablediv {
        overflow: hidden;
        resize: both;

        max-height: available;

    }

    #maintablediv:hover {
        overflow-y: scroll;

    }

    #hiddendiv{
        display: none;

        float: left;



    }

    #tableandbottom {
        display: inline-block;
    }

    #hiddendiv img {
        padding: 5px 10px 5px 5px;
        /*float: left;*/
    }

    #tableandbottom:hover > #hiddendiv{
        display: inline-block;

        /*float: left;*/

        /*width: fit-content;*/
        /*height: fit-content;*/

        width: 150px;

        padding-top: 5px;




        background-color: rgba(1,1,1,0.7);

        position: relative;
        top: -75px;
        left: 23px;


        text-align: center;

        color: white;


    }


    #maintablediv::-webkit-scrollbar-track
    {
        -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);
        background-color: rgba(1, 1, 1, 0.2);
    }

    #maintablediv::-webkit-scrollbar
    {
        width: 20px;
        height: 20px;
        background-color: rgba(0,0,0,0);
    }

    #maintablediv::-webkit-scrollbar-thumb
    {
        background-color: rgba(1,1,1,0.4);
        border: 2px solid rgba(100,100,100,0.7);
    }






    .table1
    {
        border: 5px red;
        background-color: rgba(0, 0, 0, 0);
        border-collapse: collapse;
        border-spacing: 0;
        font-size: 14px;



    }
    .table1 .traderow td
    {
        margin: 0px;
        padding: 0px;
        white-space: nowrap;
        /*border-left: 1px solid black;*/
        text-align: left;
        /*font-size: 14px;*/
        font-family: sans-serif;

        border: 0;
    }



    .traderow {
        /*border-top: 1px solid black;*/
    }

    .bitmex.size1{
        color: #5d5d5d;
        font-style: italic;
        font-size: 16px;
    }

    .bitmex.size2{
        color: #414141;
        font-size: 18px;
    }

    .bitmex.size3{
        color: black;
        font-size: 18px;
    }

    .bitmex.size4{
        color: black;
        font-size: 20px;
        font-weight: bold;

    }
    .bitmex.size5{
        color: white;
        font-size: 20px;
        font-weight: bold;
    }
    .bitmex.size6{
        color: yellow;
        border: yellow 3px;
        font-weight: bold;
        font-size: 24px;
    }

    .bitfinex.size1 {
        color: #5d5d5d;
        /*font-style: italic;*/
        font-size: 16px;

    }

    .bitfinex.size2 {
        color: #414141;
        font-size: 18px;

    }

    .bitfinex.size3 {
        color: black;

        font-size: 18px;

    }

    .bitfinex.size4 {
        color: black;
        font-weight: bold;
        font-size: 20px;

    }

    .bitfinex.size5 {
        color: #0078ff;

        font-weight: bold;

        font-size: 20px;

    }

    .bitfinex.size6 {
        font-size: 24px;
        font-weight: bold;
        color: yellow;
        border: yellow 3px;
    }

    .hide {
        display: none;
    }

    #btcAmt
    {
        /*color: #343434;*/
        font-size: 12px;
        padding-right: 5px;

    }


    #tradeSize {
        padding-left: 5px;
    }

    #tradeIcon {
        padding: 0px;
        padding-left: 4px;
    }

    #elapsedTime {
        font-size: 11px;
        font-style: italic;
        font-weight: normal;
        color: #7a7a7a;
        padding-right: 5px;
    }

    #tradePrice {
        font-size: 12px;
        padding-right: 5px;
        font-weight: normal;
        font-style: normal;
        /*color: #5a5a5a;*/
    }

    #slip {
        /*color: #59cfd9;*/
        font-size: 13px;
        font-weight: normal;
        padding-right: 5px;
        padding-left: 3px;

    }







    tr:hover {
        border: 1px solid blueviolet;
        color: blueviolet;
    }




    /* The Modal (background) */
    .modal {
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 1; /* Sit on top */
        left: 0;
        top: 0;
        width: 100%; /* Full width */
        height: 100%; /* Full height */
        overflow: auto; /* Enable scroll if needed */
        background-color: rgb(0,0,0); /* Fallback color */
        background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        -webkit-animation-name: fadeIn; /* Fade in the background */
        -webkit-animation-duration: 0.4s;
        animation-name: fadeIn;
        animation-duration: 0.4s
    }

    /* Modal Content */
    .modal-content {
        position: fixed;
        bottom: 0;
        background-color: #fefefe;
        width: 100%;
        -webkit-animation-name: slideIn;
        -webkit-animation-duration: 0.4s;
        animation-name: slideIn;
        animation-duration: 0.4s
    }

    /* The Close Button */
    .close {
        color: white;
        float: right;
        font-size: 28px;
        font-weight: bold;
    }

    .close:hover,
    .close:focus {
        color: #000;
        text-decoration: none;
        cursor: pointer;
    }

    .modal-header {
        padding: 2px 16px;
        background-color: #5cb85c;
        color: white;
    }

    .modal-body {
        padding: 10px
    }

    .settingsitem {
        padding: 10px;
    }

    .modal-footer {
        padding: 2px 16px;
        background-color: #5cb85c;
        color: white;
    }

    /* Add Animation */
    @-webkit-keyframes slideIn {
        from {bottom: -300px; opacity: 0}
        to {bottom: 0; opacity: 1}
    }

    @keyframes slideIn {
        from {bottom: -300px; opacity: 0}
        to {bottom: 0; opacity: 1}
    }

    @-webkit-keyframes fadeIn {
        from {opacity: 0}
        to {opacity: 1}
    }

    @keyframes fadeIn {
        from {opacity: 0}
        to {opacity: 1}
    }



</style>

</body></html>
